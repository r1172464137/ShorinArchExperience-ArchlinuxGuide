#!/bin/bash

# ==============================================================================
# 1. 本地化配置
# ==============================================================================
if env | grep -q "zh_CN"; then
    MSG_NO_ROOT="错误：未找到针对根目录 / 的 Snapper 配置"
    MSG_CONF_MISSING="配置文件丢失："
    MSG_CLEAN_OK="旧存档已清理"
    MSG_CLEAN_FAIL="错误：清理失败"
    MSG_SAVE_OK="已快速存档"
    MSG_SAVE_FAIL="错误：存档失败"
else
    MSG_NO_ROOT="ERROR: Snapper config for '/' not found."
    MSG_CONF_MISSING="Config file missing: "
    MSG_CLEAN_OK="Old save files cleaned."
    MSG_CLEAN_FAIL="ERROR: Clean process failed."
    MSG_SAVE_OK="Quicksaved."
    MSG_SAVE_FAIL="ERROR: Quicksave failed."
fi

# ==============================================================================
# 2. 动态检测 Snapper 配置名
# ==============================================================================
# $3 是挂载点。普通用户有权执行 list-configs。
ROOT_CONF_NAME=$(snapper list-configs | awk '$3 == "/" {print $1}')
HOME_CONF_NAME=$(snapper list-configs | awk '$3 == "/home" {print $1}')

# 如果连根目录的配置都找不到，直接报错退出
if [ -z "$ROOT_CONF_NAME" ]; then
    notify-send -u critical "$MSG_NO_ROOT"
    exit 1
fi

# ==============================================================================
# 3. 智能权限检查与修复 (使用原生 set-config)
# ==============================================================================
ROOT_CONF_FILE="/etc/snapper/configs/$ROOT_CONF_NAME"

# 先检查文件是否存在，防止对空目标操作
if [ -f "$ROOT_CONF_FILE" ]; then
    # 尝试读取配置。
    # 如果成功 (返回0)，说明权限足够，跳过 if。
    # 如果失败 (返回非0)，说明权限不足，进入 if 修复。
    if ! snapper -c "$ROOT_CONF_NAME" get-config >/dev/null 2>&1; then
        # 使用 pkexec 提权，并调用 snapper 原生命令修改配置
        # 这比 sed 更安全，且 pkexec 会处理 GUI 密码弹窗
        pkexec snapper -c "$ROOT_CONF_NAME" set-config ALLOW_GROUPS="wheel"
    fi
else
    # 配置文件物理丢失的极端情况
    notify-send -u critical "$MSG_CONF_MISSING $ROOT_CONF_FILE"
    exit 1
fi

# ==============================================================================
# 4. 执行清理
# ==============================================================================
TARGETS=("$ROOT_CONF_NAME")
[ -n "$HOME_CONF_NAME" ] && TARGETS+=("$HOME_CONF_NAME")

CLEAN_SUCCESS=true

for conf in "${TARGETS[@]}"; do
    if ! snapper -c "$conf" cleanup number; then
        CLEAN_SUCCESS=false
    fi
done

if [ "$CLEAN_SUCCESS" = true ]; then
    notify-send "$MSG_CLEAN_OK"
else
    notify-send -u critical "$MSG_CLEAN_FAIL"
fi

# ==============================================================================
# 5. 执行存档
# ==============================================================================
SAVE_SUCCESS=true

for conf in "${TARGETS[@]}"; do
    if ! snapper -c "$conf" create --description "quicksave" --cleanup-algorithm number; then
        SAVE_SUCCESS=false
    fi
done

if [ "$SAVE_SUCCESS" = true ]; then
    notify-send "$MSG_SAVE_OK"
else
    notify-send -u critical "$MSG_SAVE_FAIL"
fi

