#!/bin/bash

# ==============================================================================
# 1. 本地化配置
# ==============================================================================
if env | grep -q "zh_CN"; then
    MSG_NO_ROOT="错误：未找到针对根目录 / 的 Snapper 配置"
    MSG_CONF_MISSING="配置文件丢失："
    MSG_CLEAN_OK="旧存档已清理"
    MSG_CLEAN_FAIL="错误：清理失败"
    MSG_SAVE_OK="已快速存档"
    MSG_SAVE_FAIL="错误：存档失败"
else
    MSG_NO_ROOT="ERROR: Snapper config for '/' not found."
    MSG_CONF_MISSING="Config file missing: "
    MSG_CLEAN_OK="Old save files cleaned."
    MSG_CLEAN_FAIL="ERROR: Clean process failed."
    MSG_SAVE_OK="Quicksaved."
    MSG_SAVE_FAIL="ERROR: Quicksave failed."
fi

# ==============================================================================
# 2. 参数解析 (已修复非法选项处理)
# ==============================================================================
# 帮助信息函数
usage() {
    echo "Usage: $(basename "$0") [-d description]"
    exit 1
}

# 默认描述
DESC="quicksave"

# getopts 字符串开头的冒号 : 表示进入“静默错误模式”，由我们自己处理错误
while getopts "d:h" opt; do
  case $opt in
    d)
      DESC="$OPTARG"
      ;;
    h)
      # 显式处理 -h 选项
      usage
      ;;
    \?)
      # 捕获所有非法选项（如 -h 或其他未定义字母）
      # getopts 会将非法选项字符放入 $OPTARG
      usage
      ;;
  esac
done

# 移除已处理的参数，确保后续逻辑不受影响
shift $((OPTIND -1))

# ==============================================================================
# 3. 动态检测 Snapper 配置名
# ==============================================================================
ROOT_CONF_NAME=$(snapper list-configs | awk '$3 == "/" {print $1}')
HOME_CONF_NAME=$(snapper list-configs | awk '$3 == "/home" {print $1}')

if [ -z "$ROOT_CONF_NAME" ]; then
    notify-send -u critical "$MSG_NO_ROOT"
    exit 1
fi

# ==============================================================================
# 4. 智能权限检查与修复
# ==============================================================================
ROOT_CONF_FILE="/etc/snapper/configs/$ROOT_CONF_NAME"

if [ -f "$ROOT_CONF_FILE" ]; then
    if ! snapper -c "$ROOT_CONF_NAME" get-config >/dev/null 2>&1; then
        pkexec snapper -c "$ROOT_CONF_NAME" set-config ALLOW_GROUPS="wheel" NUMBER_LIMIT=10 NUMBER_MIN_AGE=0
    fi
else
    notify-send -u critical "$MSG_CONF_MISSING $ROOT_CONF_FILE"
    exit 1
fi

# ==============================================================================
# 5. 执行清理
# ==============================================================================
TARGETS=("$ROOT_CONF_NAME")
[ -n "$HOME_CONF_NAME" ] && TARGETS+=("$HOME_CONF_NAME")

CLEAN_SUCCESS=true

for conf in "${TARGETS[@]}"; do
    if ! snapper -c "$conf" cleanup number; then
        CLEAN_SUCCESS=false
    fi
done

# 如果不想每次清理都弹窗扰民，可以将这里的提示设为静默
 if [ "$CLEAN_SUCCESS" = true ]; then
     notify-send "$MSG_CLEAN_OK"
 fi

# ==============================================================================
# 6. 执行存档 (应用动态描述)
# ==============================================================================
SAVE_SUCCESS=true

for conf in "${TARGETS[@]}"; do
    # 使用变量 $DESC 代替硬编码的 "quicksave"
    if ! snapper -c "$conf" create --description "$DESC" --cleanup-algorithm number; then
        SAVE_SUCCESS=false
    fi
done

if [ "$SAVE_SUCCESS" = true ]; then
    # 在通知里也显示当前的描述
    notify-send "$MSG_SAVE_OK" "($DESC)"
else
    notify-send -u critical "$MSG_SAVE_FAIL"
fi
