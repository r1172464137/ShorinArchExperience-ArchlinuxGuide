#!/usr/bin/env bash
#
# quickload - Btrfs Snapshot Quick Restore Script
#

set -euo pipefail

# ==========================================
# 多语言支持 (i18n) 初始化
# ==========================================
if [[ "${LC_ALL:-${LC_MESSAGES:-${LANG:-}}}" =~ zh_CN ]]; then
    MSG_HELP_DESC="快速恢复 Btrfs 快照。支持在快照启动项和常规系统中运行。"
    MSG_HELP_OPT="选项:"
    MSG_HELP_C="  -c, --config <配置名>     跳过菜单，仅操作指定的快照配置 (例如: root)"
    MSG_HELP_N="  -n, --noconfirm           跳过菜单，直接恢复。如果不配合 -c，则全系统恢复"
    MSG_HELP_D="  -d, --description <描述>  手动指定快照描述 (默认按 quicksave -> timeline 顺序回退)"
    MSG_HELP_LC="  -lc, --list-configs       列出所有可用的快照配置名 (用于 -c 选项)"
    MSG_HELP_L="  -l, --list                列出可用的自定义快照描述 (未指定 -c 时默认仅显示 root 配置)"
    MSG_HELP_LA="  -la, --list-all           列出所有可用的快照描述 (未指定 -c 时默认仅显示 root 配置)"
    MSG_HELP_X="  -x, --debug               开启调试模式，输出日志到 /tmp/quickload_debug_EUID_PID.log"
    MSG_HELP_H="  -h, --help                显示此帮助信息"
    
    MSG_ERR_ROOT="错误: 核心回档/挂载操作需要 root 权限，且未找到提权工具 (sudo/pkexec)。"
    MSG_ERR_DEP="错误: 未找到依赖命令 '%s'，请确保已安装。\n"
    MSG_ERR_BTRFS="错误: 根文件系统不是 btrfs。"
    MSG_ERR_NOCONF="错误: 未检测到任何 snapper 配置或普通用户权限不足，尝试提取失败。"
    MSG_ERR_MATCH="错误: 在配置 [%s] 中未找到匹配的快照 (描述: %s)。\n"
    MSG_ERR_BA="错误: 未在 btrfs-assistant 中匹配到对应的回档序号。\n"
    
    MSG_CANCEL="操作已取消。"
    MSG_UNKNOWN_OPT="未知选项: %s\n"
    MSG_NEEDS_ARG="错误: %s 需要参数\n"
    MSG_TITLE="快速读档"
    
    MSG_OPT_BOTH="全系统恢复"
    MSG_OPT_ROOT="仅恢复系统目录 (root)"
    MSG_OPT_HOME="仅恢复用户目录 (home)"
    MSG_OPT_ONLY="仅恢复 %s"
    MSG_OPT_CANCEL="取消操作"
    
    MSG_LIST_CONF="=== 可用的快照配置 ==="
    MSG_LIST_CUSTOM="=== 可用的自定义快照描述 ==="
    MSG_LIST_ALL="=== 所有可用的快照描述 ==="
    MSG_LIST_EMPTY="未找到符合条件的快照描述。"
    MSG_LIST_FMT="  - %-15s [配置: %-5s | ID: %-3s | 时间: %s]\n"
    
    MSG_PROMPT="请输入序号: "
    MSG_INVALID="无效的选择，请重新输入。"
    MSG_UNKNOWN_CHOICE="无法识别的配置或选择: %s\n"
    MSG_RESTORE_DOING=">>> 正在静默执行回档项 ID: %s ...\n"
    
    MSG_NOTIFY_SUCC_TITLE="回档设定成功"
    MSG_NOTIFY_SUCC_BODY="快照恢复任务已下发。\n请立即重启系统以生效。"
    MSG_NOTIFY_ERR_TITLE="回档操作失败"
else
    MSG_HELP_DESC="Quickly restore Btrfs snapshots. Supports both normal system and snapshot boot."
    MSG_HELP_OPT="Options:"
    MSG_HELP_C="  -c, --config <config>     Skip menu, target specific config only (e.g., root)"
    MSG_HELP_N="  -n, --noconfirm           Skip menu, restore directly (full system if -c not set)"
    MSG_HELP_D="  -d, --desc <description>  Specify snapshot description manually"
    MSG_HELP_LC="  -lc, --list-configs       List all available snapshot configurations (for -c)"
    MSG_HELP_L="  -l, --list                List available custom snapshot descriptions (defaults to 'root' if no -c)"
    MSG_HELP_LA="  -la, --list-all           List all available snapshot descriptions (defaults to 'root' if no -c)"
    MSG_HELP_X="  -x, --debug               Enable debug mode, log to /tmp/quickload_debug_EUID_PID.log"
    MSG_HELP_H="  -h, --help                Show this help message"
    
    MSG_ERR_ROOT="Error: Root privileges required for action, and no escalation tool found (sudo/pkexec)."
    MSG_ERR_DEP="Error: Dependency command '%s' not found.\n"
    MSG_ERR_BTRFS="Error: Root filesystem is not btrfs."
    MSG_ERR_NOCONF="Error: No snapper configs detected or user permission denied."
    MSG_ERR_MATCH="Error: No matching snapshot found in config [%s] (Desc: %s).\n"
    MSG_ERR_BA="Error: Could not match restore ID in btrfs-assistant.\n"
    
    MSG_CANCEL="Operation cancelled."
    MSG_UNKNOWN_OPT="Unknown option: %s\n"
    MSG_NEEDS_ARG="Error: %s requires an argument\n"
    MSG_TITLE="Quickload"
    
    MSG_OPT_BOTH="Full System Restore"
    MSG_OPT_ROOT="Restore System Config (root)"
    MSG_OPT_HOME="Restore User Config (home)"
    MSG_OPT_ONLY="Restore %s"
    MSG_OPT_CANCEL="Cancel Operation"
    
    MSG_LIST_CONF="=== Available Snapshot Configurations ==="
    MSG_LIST_CUSTOM="=== Available Custom Snapshot Descriptions ==="
    MSG_LIST_ALL="=== All Available Snapshot Descriptions ==="
    MSG_LIST_EMPTY="No matching snapshot descriptions found."
    MSG_LIST_FMT="  - %-15s [Config: %-5s | ID: %-3s | Date: %s]\n"
    
    MSG_PROMPT="Enter number: "
    MSG_INVALID="Invalid selection, please try again."
    MSG_UNKNOWN_CHOICE="Unrecognized config or choice: %s\n"
    MSG_RESTORE_DOING=">>> Executing restore ID: %s silently...\n"
    
    MSG_NOTIFY_SUCC_TITLE="Restore Configured"
    MSG_NOTIFY_SUCC_BODY="Snapshot restore task is scheduled.\nPlease REBOOT immediately to apply."
    MSG_NOTIFY_ERR_TITLE="Restore Failed"
fi

print_help() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS]

${MSG_HELP_DESC}

${MSG_HELP_OPT}
${MSG_HELP_C}
${MSG_HELP_N}
${MSG_HELP_D}
${MSG_HELP_LC}
${MSG_HELP_L}
${MSG_HELP_LA}
${MSG_HELP_X}
${MSG_HELP_H}
EOF
}

# ==========================================
# 初始化与提权管理引擎
# ==========================================
OPT_DEBUG=0
for arg in "$@"; do
    case "$arg" in
        -h|--help) print_help; exit 0 ;;
        -x|--debug) OPT_DEBUG=1 ;;
    esac
done

if [[ $OPT_DEBUG -eq 1 ]]; then
    # 通过 EUID 区分日志，彻底解决 root 和 user 日志权限冲突
    LOG_FILE="/tmp/quickload_debug_${EUID}_$$.log"
    exec 2> "$LOG_FILE"
    set -x
    echo "=== 调试模式启动 (PID: $$, EUID: $EUID) ===" >&2
fi

ORIG_USER="${SUDO_USER:-}"
if [[ -z "$ORIG_USER" && -n "${PKEXEC_UID:-}" ]]; then
    ORIG_USER=$(id -nu "$PKEXEC_UID" 2>/dev/null || true)
fi

run_as_user() {
    if [[ -n "$ORIG_USER" ]] && command -v sudo >/dev/null 2>&1; then
        sudo -H -u "$ORIG_USER" WAYLAND_DISPLAY="${WAYLAND_DISPLAY:-}" XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-}" DISPLAY="${DISPLAY:-}" "$@"
    else
        "$@"
    fi
}

notify_err() {
    local msg
    msg=$(printf "$@")
    echo -e "$msg" >&2
    if [[ ! -t 0 || ! -t 1 ]] && command -v notify-send >/dev/null 2>&1; then
        run_as_user notify-send -u critical -a "Quickload" "$MSG_NOTIFY_ERR_TITLE" "$msg" 2>/dev/null || true
    fi
}

notify_ok() {
    local msg="$1"
    echo -e "$msg"
    if [[ ! -t 0 || ! -t 1 ]] && command -v notify-send >/dev/null 2>&1; then
        run_as_user notify-send -u normal -a "Quickload" "$MSG_NOTIFY_SUCC_TITLE" "$MSG_NOTIFY_SUCC_BODY" 2>/dev/null || true
    fi
}

# 延迟提权函数：仅在必要时(回档/挂载快照根)调用
require_root() {
    if [[ $EUID -ne 0 ]]; then
        local SCRIPT_PATH="$(realpath "$0")"
        if [[ -t 0 && -t 1 ]]; then
            if command -v sudo >/dev/null 2>&1; then
                exec sudo "$SCRIPT_PATH" "$@"
            else
                notify_err "$MSG_ERR_ROOT"; exit 1
            fi
        else
            if command -v pkexec >/dev/null 2>&1; then
                exec pkexec /usr/bin/env \
                    XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-}" \
                    WAYLAND_DISPLAY="${WAYLAND_DISPLAY:-}" \
                    DISPLAY="${DISPLAY:-}" \
                    LC_ALL="${LC_ALL:-}" LC_MESSAGES="${LC_MESSAGES:-}" LANG="${LANG:-}" \
                    "$SCRIPT_PATH" "$@"
            else
                notify_err "$MSG_ERR_ROOT"; exit 1
            fi
        fi
    fi
}

# ==========================================
# 参数解析
# ==========================================
OPT_CONFIG=""
OPT_DESC=""
OPT_NOCONFIRM=0
OPT_LIST=0
OPT_LIST_ALL=0
OPT_LIST_CONFIGS=0

while [[ $# -gt 0 ]]; do
    case "${1:-}" in
        -c|--config)
            if [[ $# -lt 2 ]]; then notify_err "$MSG_NEEDS_ARG" "$1"; exit 1; fi
            OPT_CONFIG="$2"; shift 2 ;;
        -n|--noconfirm) OPT_NOCONFIRM=1; shift 1 ;;
        -lc|--list-configs) OPT_LIST_CONFIGS=1; shift 1 ;;
        -l|--list) OPT_LIST=1; shift 1 ;;
        -la|--list-all) OPT_LIST_ALL=1; shift 1 ;;
        -d|--description)
            if [[ $# -lt 2 ]]; then notify_err "$MSG_NEEDS_ARG" "$1"; exit 1; fi
            OPT_DESC="$2"; shift 2 ;;
        -x|--debug) shift 1 ;; 
        -h|--help) shift 1 ;;  
        *) notify_err "$MSG_UNKNOWN_OPT" "${1:-}"; exit 1 ;;
    esac
done

# ==========================================
# 核心依赖与环境感知
# ==========================================
MOUNT_DIR=""
IS_SNAPSHOT_BOOT=0
declare -A CONFIG_MAP
CONFIG_COUNT=0
FALLBACK_DESCS=("quicksave" "timeline" "Manual Snapshot")

cleanup() {
    if [[ -n "${MOUNT_DIR:-}" && -d "${MOUNT_DIR:-}" ]]; then
        umount "$MOUNT_DIR" 2>/dev/null || true
        rmdir "$MOUNT_DIR" 2>/dev/null || true
    fi
}
trap cleanup EXIT

for cmd in btrfs snapper btrfs-assistant findmnt awk grep; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        notify_err "$MSG_ERR_DEP" "$cmd"; exit 1
    fi
done

if [[ "$(findmnt -f -n -o FSTYPE / || true)" != "btrfs" ]]; then
    notify_err "$MSG_ERR_BTRFS"; exit 1
fi

# 如果普通用户甚至没有权限读取 configs，强制提权以保证可用性
if ! snapper list-configs >/dev/null 2>&1; then
    require_root "$@"
fi

while IFS= read -r line; do
    if [[ "$line" =~ ^[[:space:]]*([^[:space:]│|]+)[[:space:]]*[│|][[:space:]]*([^[:space:]]+) ]]; then
        conf="${BASH_REMATCH[1]}"
        subvol="${BASH_REMATCH[2]}"
        CONFIG_MAP["$conf"]="$subvol"
        CONFIG_COUNT=$((CONFIG_COUNT + 1))
    fi
done < <(snapper list-configs 2>/dev/null | tail -n +3 || true)

if [[ $CONFIG_COUNT -eq 0 ]]; then
    notify_err "$MSG_ERR_NOCONF"; exit 1
fi

if [[ $OPT_LIST_CONFIGS -eq 1 ]]; then
    echo "$MSG_LIST_CONF"
    for conf in "${!CONFIG_MAP[@]}"; do
        echo "  - $conf"
    done
    exit 0
fi

# 探测快照启动环境：挂载顶级子卷需要 Root，立即拦截提权
SOURCE_LINE=$(findmnt -n -o SOURCE / || true)
if [[ "$SOURCE_LINE" == *".snapshots"* ]]; then
    IS_SNAPSHOT_BOOT=1
    require_root "$@"
    
    DEVICE=$(echo "$SOURCE_LINE" | cut -d'[' -f1)
    SUBVOL_PATH=$(echo "$SOURCE_LINE" | cut -d'[' -f2 | cut -d']' -f1)
    BASE_SUBVOL="${SUBVOL_PATH%%/.snapshots*}"
    [[ -z "$BASE_SUBVOL" ]] && BASE_SUBVOL="/"
    
    MOUNT_DIR=$(mktemp -d /tmp/quickload_root_XXXX)
    mount -t btrfs -o subvol="$BASE_SUBVOL" "$DEVICE" "$MOUNT_DIR"
fi

# ==========================================
# 工具函数
# ==========================================
get_snapper_list_output() {
    local conf="$1"
    local subvol="${CONFIG_MAP[$conf]:-}"
    if [[ "$IS_SNAPSHOT_BOOT" == 1 && "$subvol" == "/" ]]; then
        snapper --no-dbus --root "$MOUNT_DIR" list || true
    else
        snapper -c "$conf" list || true
    fi
}

list_snapshot_descriptions() {
    local show_all="$1"
    local descs_raw=()
    local configs_to_list=()
    
    if [[ -n "$OPT_CONFIG" ]]; then
        if [[ -n "${CONFIG_MAP[$OPT_CONFIG]:-}" ]]; then
            configs_to_list=("$OPT_CONFIG")
        else
            notify_err "$MSG_UNKNOWN_CHOICE" "$OPT_CONFIG"; exit 1
        fi
    else
        # 限定未指定 -c 时，默认只显示 root (若存在)
        if [[ -n "${CONFIG_MAP["root"]:-}" ]]; then
            configs_to_list=("root")
        else
            configs_to_list=("${!CONFIG_MAP[@]}")
        fi
    fi
    
    if [[ "$show_all" == 1 ]]; then
        echo "$MSG_LIST_ALL"
    else
        echo "$MSG_LIST_CUSTOM"
    fi
    
    for conf in "${configs_to_list[@]}"; do
        local list_out
        list_out=$(get_snapper_list_output "$conf")
        
        while IFS='|' read -r sid date desc; do
            desc="${desc#"${desc%%[![:space:]]*}"}"; desc="${desc%"${desc##*[![:space:]]}"}"
            date="${date#"${date%%[![:space:]]*}"}"; date="${date%"${date##*[![:space:]]}"}"
            sid="${sid#"${sid%%[![:space:]]*}"}"; sid="${sid%"${sid##*[![:space:]]}"}"
            
            if [[ -z "$desc" || "$desc" == "Description" || "$desc" == "描述" || "$desc" == "current" ]]; then
                continue
            fi
            if [[ "$show_all" == 0 ]]; then
                if [[ "$desc" == "quicksave" || "$desc" == "timeline" || "$desc" == "Manual Snapshot" ]]; then
                    continue
                fi
            fi
            descs_raw+=("$desc|$conf|$sid|$date")
        done < <(echo "$list_out" | awk -F' *[|│] *' 'NR>2 {print $1 "|" $4 "|" $7}')
    done
    
    if [[ ${#descs_raw[@]} -gt 0 ]]; then
        readarray -t sorted_descs < <(printf "%s\n" "${descs_raw[@]}" | sort -t'|' -k1,1 -k2,2 -k3,3n)
        for entry in "${sorted_descs[@]}"; do
            IFS='|' read -r desc conf sid date <<< "$entry"
            printf "$MSG_LIST_FMT" "$desc" "$conf" "$sid" "$date"
        done
    else
        echo "  $MSG_LIST_EMPTY"
    fi
}

if [[ $OPT_LIST -eq 1 ]]; then list_snapshot_descriptions 0; exit 0; fi
if [[ $OPT_LIST_ALL -eq 1 ]]; then list_snapshot_descriptions 1; exit 0; fi

TARGET_DESC=""
if [[ -n "$OPT_DESC" ]]; then
    TARGET_DESC="$OPT_DESC"
else
    for test_desc in "${FALLBACK_DESCS[@]}"; do
        test_conf=$(echo "${!CONFIG_MAP[@]}" | awk '{print $1}' || true)
        test_out=$(get_snapper_list_output "$test_conf")
        if echo "$test_out" | awk -F' *[|│] *' -v d="$test_desc" 'NR>2 && $7 == d {found=1} END {exit !found}'; then
            TARGET_DESC="$test_desc"
            break
        fi
    done
fi
[[ -z "$TARGET_DESC" ]] && TARGET_DESC="quicksave"

get_snap_id_by_desc() {
    local conf="$1"; local desc="$2"; local list_out
    list_out=$(get_snapper_list_output "$conf")
    echo "$list_out" | awk -F' *[|│] *' -v d="$desc" 'NR>2 && $7 == d {print $1}' | tail -n 1 || true
}

get_btrfs_subvol_name() {
    local mount_point="$1"
    local source_line
    source_line=$(findmnt -n -o SOURCE "$mount_point" || true)
    
    if [[ "$source_line" == *"["* ]]; then
        local subvol_path=$(echo "$source_line" | cut -d'[' -f2 | cut -d']' -f1)
        local base_subvol="${subvol_path%%/.snapshots*}"
        base_subvol="${base_subvol%%_backup_*}"
        echo "${base_subvol#/}"
    else
        local cleaned_line="${source_line#/}"
        cleaned_line="${cleaned_line%%_backup_*}"
        echo "$cleaned_line" | awk -F'/' '{print $NF}' || true
    fi
}

# ==========================================
# 核心执行引擎 (需要高权限)
# ==========================================
execute_restore() {
    local selected_action="$1"

    if [[ "$selected_action" == "cancel" ]]; then
        echo "$MSG_CANCEL"
        exit 0
    fi

    # 拦截提权点：如果仍是普通用户，携带决定好的目标参数重新唤醒自身 (此时触发密码)
    if [[ $EUID -ne 0 ]]; then
        local new_args=("-n" "-c" "$selected_action")
        [[ -n "$TARGET_DESC" ]] && new_args+=("-d" "$TARGET_DESC")
        [[ $OPT_DEBUG -eq 1 ]] && new_args+=("-x")
        require_root "${new_args[@]}"
    fi

    local configs_to_restore=()
    if [[ "$selected_action" == "all" ]]; then
        configs_to_restore=("${!CONFIG_MAP[@]}")
    else
        if [[ -z "${CONFIG_MAP[$selected_action]:-}" ]]; then
            notify_err "$MSG_UNKNOWN_CHOICE" "$selected_action"
            exit 1
        fi
        configs_to_restore=("$selected_action")
    fi

    # 预加载列表以减少进程呼叫开销
    local ba_list_output=$(btrfs-assistant -l || true)
    local restore_ba_ids=()

    for conf in "${configs_to_restore[@]}"; do
        local snap_id=""
        if [[ -n "$OPT_DESC" ]]; then
            snap_id=$(get_snap_id_by_desc "$conf" "$OPT_DESC")
        else
            for d in "${FALLBACK_DESCS[@]}"; do
                snap_id=$(get_snap_id_by_desc "$conf" "$d")
                [[ -n "$snap_id" ]] && break
            done
        fi

        if [[ -z "$snap_id" ]]; then
            notify_err "$MSG_ERR_MATCH" "$conf" "${OPT_DESC:-Fallback序列}"
            exit 1
        fi

        local mnt="${CONFIG_MAP[$conf]}"
        local base_subvol=$(get_btrfs_subvol_name "$mnt")
        
        local ba_id=$(echo "$ba_list_output" | awk -v subv="$base_subvol" -v sid="$snap_id" '$2 == subv && $3 == sid {print $1}' || true)
        
        if [[ -z "$ba_id" ]]; then
            notify_err "$MSG_ERR_BA"
            exit 1
        fi
        restore_ba_ids+=("$ba_id")
    done

    for ba_id in "${restore_ba_ids[@]}"; do
        printf "$MSG_RESTORE_DOING" "$ba_id"
        env -u DISPLAY -u WAYLAND_DISPLAY -u XDG_RUNTIME_DIR btrfs-assistant -r "$ba_id"
    done
    
    notify_ok "======================================\n$MSG_NOTIFY_SUCC_BODY\n======================================"
}

if [[ $OPT_NOCONFIRM -eq 1 || -n "$OPT_CONFIG" ]]; then
    if [[ -n "$OPT_CONFIG" ]]; then
        execute_restore "$OPT_CONFIG"
    else
        execute_restore "all"
    fi
    exit 0
fi

# ==========================================
# 交互式 UI 菜单生成 (普通用户侧执行)
# ==========================================
MENU_TITLE="$MSG_TITLE"
[[ -n "$TARGET_DESC" ]] && MENU_TITLE="$MSG_TITLE [$TARGET_DESC]"

declare -A CHOICE_MAP
MENU_OPTS=("$MSG_OPT_BOTH")
CHOICE_MAP["$MSG_OPT_BOTH"]="all"

for conf in "${!CONFIG_MAP[@]}"; do
    if [[ "$conf" == "root" ]]; then
        MENU_OPTS+=("$MSG_OPT_ROOT")
        CHOICE_MAP["$MSG_OPT_ROOT"]="root"
    elif [[ "$conf" == "home" ]]; then
        MENU_OPTS+=("$MSG_OPT_HOME")
        CHOICE_MAP["$MSG_OPT_HOME"]="home"
    else
        opt_str="$(printf "$MSG_OPT_ONLY" "$conf")"
        MENU_OPTS+=("$opt_str")
        CHOICE_MAP["$opt_str"]="$conf"
    fi
done

MENU_OPTS+=("$MSG_OPT_CANCEL")
CHOICE_MAP["$MSG_OPT_CANCEL"]="cancel"
CHOICE=""

if [[ -t 0 && -t 1 ]]; then
    echo "=== $MENU_TITLE ==="
    for i in "${!MENU_OPTS[@]}"; do
        printf "  %d) %s\n" "$((i + 1))" "${MENU_OPTS[$i]}"
    done
    
    while true; do
        read -p "$MSG_PROMPT" user_input
        if [[ "$user_input" =~ ^[0-9]+$ ]] && (( user_input > 0 && user_input <= ${#MENU_OPTS[@]} )); then
            CHOICE="${MENU_OPTS[$((user_input - 1))]}"
            break
        else
            echo "$MSG_INVALID"
        fi
    done
else
    # 彻底解决主题问题：由于此时绝大概率尚未提权，Fuzzel/Wofi 跑的本来就是当前用户，主题完美复现！
    # 即使在快照环境里跑成了 root，也能通过 run_as_user 降权读回主题。
    OPTS_STR=$(printf "%s\n" "${MENU_OPTS[@]}")
    if command -v fuzzel >/dev/null 2>&1; then
        CHOICE=$(echo -e "$OPTS_STR" | run_as_user fuzzel --dmenu --prompt="$MENU_TITLE > " 2>/dev/null || true)
    elif command -v wofi >/dev/null 2>&1; then
        CHOICE=$(echo -e "$OPTS_STR" | run_as_user wofi --dmenu --prompt="$MENU_TITLE" 2>/dev/null || true)
    elif command -v rofi >/dev/null 2>&1; then
        CHOICE=$(echo -e "$OPTS_STR" | run_as_user rofi -dmenu -p "$MENU_TITLE" 2>/dev/null || true)
    elif command -v zenity >/dev/null 2>&1; then
        CHOICE=$(echo -e "$OPTS_STR" | run_as_user zenity --list --title="$MENU_TITLE" --column="选项" --hide-header 2>/dev/null || true)
    fi
fi

[[ -z "$CHOICE" ]] && exit 0
SELECTION="${CHOICE_MAP["$CHOICE"]:-}"

if [[ -n "$SELECTION" ]]; then
    execute_restore "$SELECTION"
else
    notify_err "$MSG_UNKNOWN_CHOICE" "$CHOICE"
    exit 1
fi
