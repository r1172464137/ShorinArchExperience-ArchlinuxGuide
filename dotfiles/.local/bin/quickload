#!/bin/bash

SCRIPT_PATH=$(realpath "$0")

# --- 语言检测优化与帮助文档 ---
if echo "$LANG" | grep -q "zh_CN"; then
    TXT_PROMPT="快速读档 > ⚠️会自动重启系统"
    TXT_BOTH="全系统恢复 (both)"
    TXT_ROOT="仅恢复root (root)"
    TXT_HOME="仅恢复home (home)"
    TXT_CANCEL="取消 (cancel)" 
    
    MSG_TITLE="系统恢复"
    MSG_START="正在进行恢复，请勿关闭电脑..."
    MSG_SUCCESS="恢复成功！3秒后自动重启..."
    MSG_FAIL="恢复失败。"
    MSG_NO_SNAP="未找到目标快照："
    MSG_MAP_FAIL="无法映射快照 ID："

    TXT_HELP_USAGE="用法: quickload [选项] [模式]
一个防弹版的 Btrfs 快照回滚工具，支持图形界面 (Fuzzel) 与 TTY 终端。

选项:
  -h, --help        显示此帮助信息并退出。
  -d <描述>         指定要回滚的快照描述文字 (默认: quicksave)。

模式:
  both              恢复 root 和 home 快照。
  root              仅恢复 root 快照。
  home              仅恢复 home 快照。

注意: 
  如果不提供 [模式]，将自动根据当前环境弹出图形菜单或终端文字菜单。

示例:
  quickload                                 # 弹出菜单，默认读取 quicksave
  quickload both                            # 跳过菜单，直接全系统恢复 quicksave
  quickload -d \"Before Shorin Setup\" root   # 仅恢复 root 到指定描述的快照"
else
    TXT_PROMPT="Quickload > ⚠️ System will reboot"
    TXT_BOTH="Full Restore (both)"
    TXT_ROOT="Restore Root Only (root)"
    TXT_HOME="Restore Home Only (home)"
    TXT_CANCEL="Cancel"

    MSG_TITLE="System Restore"
    MSG_START="Restoring in progress, do not turn off..."
    MSG_SUCCESS="Success! Rebooting in 3s..."
    MSG_FAIL="Restore failed."
    MSG_NO_SNAP="No target snapshot found for:"
    MSG_MAP_FAIL="Map failed for:"

    TXT_HELP_USAGE="Usage: quickload [OPTIONS] [MODE]
A bulletproof Btrfs snapshot rollback tool supporting GUI (Fuzzel) and TTY.

Options:
  -h, --help        Show this help message and exit.
  -d <description>  Specify target snapshot description (Default: quicksave).

Modes:
  both              Restore both root and home snapshots.
  root              Restore root snapshot only.
  home              Restore home snapshot only.

Note:
  If [MODE] is not provided, an interactive menu will be shown based on your environment.

Examples:
  quickload                                 # Show menu, default to quicksave
  quickload both                            # Direct full restore of quicksave
  quickload -d \"Before Shorin Setup\" root   # Restore root only to specific snapshot"
fi

# ==============================================================================
# --- Root 执行逻辑 (底层回滚) ---
# ==============================================================================
if [ "$1" == "--internal-run-as-root" ]; then
    MODE="$2"
    TARGET_SNAP="${3:-quicksave}" # 接收透传的快照名称，默认 fallback 为 quicksave
    
    # 1. 自动检测是否在快照启动项中
    IS_SNAPSHOT_BOOT=false
    REAL_ROOT_MNT="/tmp/btrfs_real_root"
    
    if findmnt -n -o OPTIONS / | grep -q "snapshots"; then
        IS_SNAPSHOT_BOOT=true
        ROOT_DEV=$(findmnt -n -o SOURCE / | cut -d'[' -f1)
        
        mkdir -p "$REAL_ROOT_MNT"
        if ! mountpoint -q "$REAL_ROOT_MNT"; then
            mount -t btrfs -o subvolid=5 "$ROOT_DEV" "$REAL_ROOT_MNT"
        fi
    fi

    # 2. 清理钩子
    cleanup_mount() {
        if [ "$IS_SNAPSHOT_BOOT" = true ] && mountpoint -q "$REAL_ROOT_MNT"; then
            umount "$REAL_ROOT_MNT"
            rmdir "$REAL_ROOT_MNT"
        fi
    }
    trap cleanup_mount EXIT

    # 3. 执行回滚逻辑
    rollback_subvol() {
        local subvol=$1       
        local snap_conf=$2    
        local SNAPPER_CMD="snapper -c $snap_conf"
        
        if [ "$IS_SNAPSHOT_BOOT" = true ] && [ "$snap_conf" == "root" ]; then
            SNAPPER_CMD="snapper --no-dbus --root ${REAL_ROOT_MNT}/@ -c root"
        fi
        
        local snap_id=$($SNAPPER_CMD list --columns number,description | grep "$TARGET_SNAP" | tail -n 1 | awk '{print $1}')
        if [ -z "$snap_id" ]; then echo "$MSG_NO_SNAP $snap_conf ($TARGET_SNAP)"; return 1; fi

        local ba_index=$(btrfs-assistant -l | awk -v v="$subvol" -v s="$snap_id" '$2==v && $3==s {print $1}')
        if [ -z "$ba_index" ]; then echo "$MSG_MAP_FAIL $subvol (ID: $snap_id)"; return 1; fi

        btrfs-assistant -r "$ba_index"
    }

    if [[ "$MODE" == "both" || "$MODE" == "root" ]]; then rollback_subvol "@" "root" || exit 1; fi
    if [[ "$MODE" == "both" || "$MODE" == "home" ]]; then rollback_subvol "@home" "home" || exit 1; fi
    
    exit 0
fi

# ==============================================================================
# --- 环境感知与交互逻辑 ---
# ==============================================================================

# 优先拦截帮助参数 (-h / --help)
for arg in "$@"; do
    if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
        echo -e "$TXT_HELP_USAGE"
        exit 0
    fi
done

# 极简参数拦截：如果第一个参数是 -d，提取描述并踢掉前两个参数
TARGET_SNAP="quicksave"
if [[ "$1" == "-d" && -n "$2" ]]; then
    TARGET_SNAP="$2"
    shift 2
fi

# 判断是否拥有图形界面
HAS_GUI=false
if [[ -n "$WAYLAND_DISPLAY" || -n "$DISPLAY" ]]; then
    HAS_GUI=true
fi

notify_user() {
    local level="$1" 
    local msg="$2"
    if [ "$HAS_GUI" = true ] && command -v notify-send >/dev/null; then
        if [ "$level" == "critical" ]; then
            notify-send -u critical "$MSG_TITLE" "$msg"
        else
            notify-send "$MSG_TITLE" "$msg"
        fi
    else
        echo -e "\n[ $MSG_TITLE ] $msg\n"
    fi
}

TARGET_MODE=""

# 剩下的第一个参数就是目标模式 (如 both)
if [[ "$1" == "both" || "$1" == "root" || "$1" == "home" ]]; then
    TARGET_MODE="$1"
else
    # 动态修改菜单标题，把目标快照名字显示出来
    PROMPT_TEXT="$TXT_PROMPT [$TARGET_SNAP]"
    
    if [ "$HAS_GUI" = true ] && command -v fuzzel >/dev/null; then
        SELECTION=$(printf "$TXT_BOTH\n$TXT_ROOT\n$TXT_HOME\n$TXT_CANCEL" | fuzzel -d -p "$PROMPT_TEXT")
        case "$SELECTION" in
            "$TXT_BOTH") TARGET_MODE="both" ;;
            "$TXT_ROOT") TARGET_MODE="root" ;;
            "$TXT_HOME") TARGET_MODE="home" ;;
            *) exit 0 ;; 
        esac
    else
        echo "========================================="
        echo "   $PROMPT_TEXT"
        echo "========================================="
        echo " 1) $TXT_BOTH"
        echo " 2) $TXT_ROOT"
        echo " 3) $TXT_HOME"
        echo " 4) $TXT_CANCEL"
        echo "========================================="
        read -p "请选择 (1-4): " tty_sel
        case "$tty_sel" in
            1) TARGET_MODE="both" ;;
            2) TARGET_MODE="root" ;;
            3) TARGET_MODE="home" ;;
            *) exit 0 ;;
        esac
    fi
fi

if [ -z "$TARGET_MODE" ]; then
    exit 0
fi

# ==============================================================================
# --- 执行提权与重启 ---
# ==============================================================================
notify_user "normal" "$MSG_START"

# 极简透传：直接把 $TARGET_SNAP 塞进字符串最后面
if pkexec su - root -c "LANG=\"$LANG\" \"$SCRIPT_PATH\" --internal-run-as-root \"$TARGET_MODE\" \"$TARGET_SNAP\""; then
    notify_user "critical" "$MSG_SUCCESS"
    sleep 3
    systemctl reboot
else
    notify_user "critical" "$MSG_FAIL"
fi
