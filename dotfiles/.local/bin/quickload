#!/usr/bin/env bash
# ==============================================================================
# Quickload - Btrfs Snapshot Rollback Tool (Matugen UI Edition)
# ==============================================================================
set -euo pipefail

SCRIPT_PATH=$(realpath "${BASH_SOURCE[0]}")

# ==============================================================================
# --- 终端 UI 颜色配置 (适配 Matugen) ---
# ==============================================================================
readonly C_BOLD='\x1b[1m'
# Matugen 基础配色
readonly C_PRIMARY='\x1b[1;34m'
readonly C_TERTIARY='\x1b[1;35m'
readonly C_CYAN='\x1b[1;36m'
readonly C_RESET='\x1b[0m'
# 补充辅助配色
readonly C_GOLD='\x1b[1;33m'      # 用于高亮当前正在执行的步骤
readonly C_ERROR='\x1b[1;31m'     # 用于致命错误提示
readonly C_GRAY='\x1b[38;5;245m'  # 用于边框和次要信息

# --- 语言检测优化 ---
if [[ "${LANG:-}" == *"zh_CN"* ]]; then
    readonly TXT_PROMPT="快速读档 > 自动重启"
    readonly TXT_BOTH="全系统恢复 (both)"
    readonly TXT_ROOT="仅恢复根目录 (root)"
    readonly TXT_HOME="仅恢复用户目录 (home)"
    readonly TXT_CANCEL="取消操作 (cancel)" 
    
    readonly MSG_TITLE="系统恢复系统"
    readonly MSG_START="正在准备底层环境..."
    readonly MSG_SUCCESS="恢复指令下达成功！3秒后自动重启..."
    readonly MSG_FAIL="发生致命错误，恢复中止。"
else
    readonly TXT_PROMPT="Quickload > Will reboot"
    readonly TXT_BOTH="Full Restore (both)"
    readonly TXT_ROOT="Restore Root Only (root)"
    readonly TXT_HOME="Restore Home Only (home)"
    readonly TXT_CANCEL="Cancel"

    readonly MSG_TITLE="System Restore"
    readonly MSG_START="Preparing environment..."
    readonly MSG_SUCCESS="Success! Rebooting in 3s..."
    readonly MSG_FAIL="Fatal error, restore aborted."
fi

# ==============================================================================
# --- Root 执行逻辑 (底层回滚与 Matugen UI) ---
# ==============================================================================
if [[ "${1:-}" == "--internal-run-as-root" ]]; then
    MODE="${2:-}"
    TARGET_SNAP="${3:-quicksave}" 
    
    IS_SNAPSHOT_BOOT="false"
    REAL_ROOT_MNT="/tmp/btrfs_real_root"
    
    if findmnt -n -o OPTIONS / 2>/dev/null | grep -q "snapshots" || false; then
        IS_SNAPSHOT_BOOT="true"
        ROOT_DEV=$(findmnt -n -o SOURCE / 2>/dev/null | cut -d'[' -f1 || true)
        
        if [[ -n "$ROOT_DEV" ]]; then
            mkdir -p "$REAL_ROOT_MNT"
            if ! mountpoint -q "$REAL_ROOT_MNT"; then
                mount -t btrfs -o subvolid=5 "$ROOT_DEV" "$REAL_ROOT_MNT" 2>/dev/null || true
            fi
        fi
    fi

    cleanup_mount() {
        if [[ "$IS_SNAPSHOT_BOOT" == "true" ]] && mountpoint -q "$REAL_ROOT_MNT"; then
            umount "$REAL_ROOT_MNT" 2>/dev/null || true
            rmdir "$REAL_ROOT_MNT" 2>/dev/null || true
        fi
    }
    trap cleanup_mount EXIT

    rollback_subvol() {
        local subvol="$1"
        local snap_conf="$2"
        local snapper_cmd="snapper -c $snap_conf"
        
        if [[ "$IS_SNAPSHOT_BOOT" == "true" ]] && [[ "$snap_conf" == "root" ]]; then
            snapper_cmd="snapper --no-dbus --root ${REAL_ROOT_MNT}/@ -c root"
        fi
        
        echo -e "\n${C_BOLD}${C_PRIMARY}::${C_RESET} ${C_BOLD}正在处理子卷: ${C_TERTIARY}${subvol}${C_RESET}"
        
        local snap_id=""
        snap_id=$($snapper_cmd list --columns number,description 2>/dev/null | awk -v tgt="$TARGET_SNAP" '$0 ~ tgt {print $1}' | tail -n 1) || true

        if [[ -z "$snap_id" ]]; then 
            echo -e "   ${C_BOLD}${C_ERROR}[ERROR]${C_RESET} 未找到描述为 [${TARGET_SNAP}] 的快照记录。"
            return 1
        fi
        echo -e "   ${C_BOLD}${C_PRIMARY}[OK]${C_RESET} 匹配快照 : ${C_CYAN}$TARGET_SNAP${C_RESET} ${C_GRAY}(ID: $snap_id)${C_RESET}"

        local ba_index=""
        ba_index=$(btrfs-assistant -l 2>/dev/null | awk -v v="$subvol" -v s="$snap_id" '$2==v && $3==s {print $1}') || true

        if [[ -z "$ba_index" ]]; then 
            echo -e "   ${C_BOLD}${C_ERROR}[ERROR]${C_RESET} 无法将快照 ID $snap_id 映射到底层引擎。"
            return 1
        fi
        echo -e "   ${C_BOLD}${C_PRIMARY}[OK]${C_RESET} 引擎就绪 : ${C_GRAY}(内部索引: $ba_index)${C_RESET}"

        # 核心变动：当前阻塞执行的步骤使用高亮的金色显示，移除多余符号
        echo -e "   ${C_BOLD}${C_GOLD}-> 正在执行底层回滚指令...${C_RESET}"
        echo -e "   ${C_GRAY}╭──────────────────────────────────────────────────${C_RESET}"
        
        if btrfs-assistant -r "$ba_index" 2>&1 | sed "s/^/   ${C_GRAY}│${C_RESET} /"; then
            echo -e "   ${C_GRAY}╰──────────────────────────────────────────────────${C_RESET}"
            echo -e "   ${C_BOLD}${C_PRIMARY}[DONE] $subvol 子卷回滚已成功完成。${C_RESET}"
        else
            echo -e "   ${C_GRAY}╰──────────────────────────────────────────────────${C_RESET}"
            echo -e "   ${C_BOLD}${C_ERROR}[FATAL] $subvol 子卷回滚遇到致命错误，请检查上方日志。${C_RESET}"
            return 1
        fi
    }

    echo -e "\n${C_BOLD}${C_PRIMARY}=================[ BTRFS 极速回滚 ]=================${C_RESET}"
    echo -e "${C_BOLD}   执行模式 : ${C_CYAN}$MODE${C_RESET}"
    echo -e "${C_BOLD}   目标快照 : ${C_TERTIARY}$TARGET_SNAP${C_RESET}"
    echo -e "${C_BOLD}${C_PRIMARY}====================================================${C_RESET}"

    if [[ "$MODE" == "both" || "$MODE" == "root" ]]; then rollback_subvol "@" "root" || exit 1; fi
    if [[ "$MODE" == "both" || "$MODE" == "home" ]]; then rollback_subvol "@home" "home" || exit 1; fi
    
    echo -e "\n${C_BOLD}${C_PRIMARY}=================[ 所有任务已结束 ]=================${C_RESET}\n"
    exit 0
fi

# ==============================================================================
# --- 环境感知与交互逻辑 ---
# ==============================================================================

TARGET_SNAP="quicksave"
if [[ "${1:-}" == "-d" && -n "${2:-}" ]]; then
    TARGET_SNAP="$2"
    shift 2
fi

HAS_GUI="false"
if [[ -n "${WAYLAND_DISPLAY:-}" || -n "${DISPLAY:-}" ]]; then
    HAS_GUI="true"
fi

notify_user() {
    local level="$1" 
    local msg="$2"
    
    if [[ "$HAS_GUI" == "true" ]] && command -v notify-send >/dev/null 2>&1; then
        if [[ "$level" == "critical" ]]; then
            notify-send -u critical "$MSG_TITLE" "$msg" 2>/dev/null || true
        else
            notify-send "$MSG_TITLE" "$msg" 2>/dev/null || true
        fi
    fi
}

TARGET_MODE=""

if [[ "${1:-}" == "both" || "${1:-}" == "root" || "${1:-}" == "home" ]]; then
    TARGET_MODE="$1"
else
    PROMPT_TEXT="$TXT_PROMPT [$TARGET_SNAP]"
    SELECTION=""
    
    if [[ "$HAS_GUI" == "true" ]] && command -v fuzzel >/dev/null 2>&1; then
        SELECTION=$(printf "%s\n%s\n%s\n%s" "$TXT_BOTH" "$TXT_ROOT" "$TXT_HOME" "$TXT_CANCEL" | fuzzel -d -p "$PROMPT_TEXT" 2>/dev/null) || true
    fi

    if [[ -n "$SELECTION" ]]; then
        case "$SELECTION" in
            "$TXT_BOTH") TARGET_MODE="both" ;;
            "$TXT_ROOT") TARGET_MODE="root" ;;
            "$TXT_HOME") TARGET_MODE="home" ;;
            *) exit 0 ;; 
        esac
    else
        echo -e "\n${C_BOLD}${C_PRIMARY}==============[ QUICKLOAD 读档程序 ]==============${C_RESET}"
        echo -e "${C_BOLD}   目标快照: ${C_TERTIARY}$TARGET_SNAP${C_RESET}"
        echo -e "${C_BOLD}${C_PRIMARY}==================================================${C_RESET}"
        echo -e " 1) ${C_CYAN}$TXT_BOTH${C_RESET}"
        echo -e " 2) ${C_PRIMARY}$TXT_ROOT${C_RESET}"
        echo -e " 3) ${C_PRIMARY}$TXT_HOME${C_RESET}"
        echo -e " 4) ${C_GRAY}$TXT_CANCEL${C_RESET}"
        echo -e "${C_BOLD}${C_PRIMARY}==================================================${C_RESET}"
        
        tty_sel=""
        read -r -p "$(echo -e ${C_BOLD}请选择序号 ${C_GOLD}[1-4]${C_RESET}: )" tty_sel || true
        case "${tty_sel:-}" in
            1) TARGET_MODE="both" ;;
            2) TARGET_MODE="root" ;;
            3) TARGET_MODE="home" ;;
            *) exit 0 ;;
        esac
    fi
fi

if [[ -z "$TARGET_MODE" ]]; then exit 0; fi

# ==============================================================================
# --- 执行提权与重启 ---
# ==============================================================================
notify_user "normal" "$MSG_START"

execute_rollback() {
    env LANG="${LANG:-C}" "$SCRIPT_PATH" --internal-run-as-root "$TARGET_MODE" "$TARGET_SNAP"
}

if [[ "$(id -u)" == "0" ]]; then
    if execute_rollback; then
        notify_user "critical" "$MSG_SUCCESS"
        sleep 3
        systemctl reboot
    else
        notify_user "critical" "$MSG_FAIL"
        exit 1
    fi
else
    if pkexec su - root -c "env LANG=\"${LANG:-C}\" \"$SCRIPT_PATH\" --internal-run-as-root \"$TARGET_MODE\" \"$TARGET_SNAP\"" 2>/dev/null; then
        notify_user "critical" "$MSG_SUCCESS"
        sleep 3
        systemctl reboot
    else
        notify_user "critical" "$MSG_FAIL"
        exit 1
    fi
fi
