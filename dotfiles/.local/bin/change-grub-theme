#!/usr/bin/env bash
set -Eeuo pipefail

# ================= 配置区域 =================
# 获取真实用户的 Home 目录（因为脚本需要 sudo 运行）
REAL_USER="${SUDO_USER:-$USER}"
REAL_HOME=$(getent passwd "$REAL_USER" | cut -d: -f6)

# 主题源目录 (根据你的描述)
THEME_SOURCE_DIR="$REAL_HOME/.local/share/shorin-niri/grub-themes"

# GRUB 目标链接位置
GRUB_THEMES_DIR="/boot/grub/themes"
LINK_NAME="current-theme"
LINK_PATH="$GRUB_THEMES_DIR/$LINK_NAME"

# GRUB 配置文件
GRUB_DEFAULT="/etc/default/grub"

# 颜色定义
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# ================= 函数定义 =================

check_root() {
    if [[ $EUID -ne 0 ]]; then
        echo -e "${RED}错误: 此脚本需要 root 权限来修改 /boot 和 GRUB 配置。${NC}"
        echo -e "请使用 sudo 运行此脚本。"
        exit 1
    fi
}

check_source_dir() {
    if [[ ! -d "$THEME_SOURCE_DIR" ]]; then
        echo -e "${RED}错误: 主题源目录不存在: $THEME_SOURCE_DIR${NC}"
        exit 1
    fi
}

update_grub_config() {
    echo -e "${BLUE}正在更新 GRUB 配置...${NC}"
    
    # 1. 确保 GRUB_THEME 行存在且正确
    local theme_line="GRUB_THEME=\"$LINK_PATH/theme.txt\""
    
    # 如果文件中已经有 GRUB_THEME，替换它
    if grep -q "^GRUB_THEME=" "$GRUB_DEFAULT"; then
        sed -i "s|^GRUB_THEME=.*|$theme_line|" "$GRUB_DEFAULT"
    else
        # 如果没有，追加到末尾
        echo "$theme_line" >> "$GRUB_DEFAULT"
    fi
    
    echo -e "已设置: $theme_line"

    # 2. 生成新的 grub.cfg
    echo -e "${BLUE}正在生成新的 boot loader 配置...${NC}"
    if command -v update-grub &> /dev/null; then
        update-grub
    elif command -v grub-mkconfig &> /dev/null; then
        grub-mkconfig -o /boot/grub/grub.cfg
    elif command -v grub2-mkconfig &> /dev/null; then
        grub2-mkconfig -o /boot/grub2/grub.cfg
    else
        echo -e "${RED}未找到 update-grub 或 grub-mkconfig 命令。请手动更新 GRUB。${NC}"
        return 1
    fi
}

main() {
    check_root
    check_source_dir

    echo -e "${BLUE}正在扫描主题...${NC}"
    
    # 使用数组存储找到的主题路径
    local -a theme_paths
    local -a theme_names
    
    # 递归查找 theme.txt
    # 使用 while read loop 处理 find 输出，防止文件名带空格出问题
    while IFS= read -r file; do
        dir_path=$(dirname "$file")
        # 获取相对路径作为显示名称，避免混淆
        # 例如: .../grub-themes/pack1/cyberpunk/theme.txt -> pack1/cyberpunk
        relative_path="${dir_path#$THEME_SOURCE_DIR/}"
        
        theme_paths+=("$dir_path")
        theme_names+=("$relative_path")
    done < <(find "$THEME_SOURCE_DIR" -name "theme.txt" | sort)

    if [[ ${#theme_paths[@]} -eq 0 ]]; then
        echo -e "${RED}在 $THEME_SOURCE_DIR 下未找到任何 theme.txt 文件。${NC}"
        exit 1
    fi

    echo -e "${GREEN}发现 ${#theme_paths[@]} 个主题:${NC}"
    
    # 显示菜单
    PS3="请输入序号选择主题 (输入 q 退出): "
    select choice in "${theme_names[@]}"; do
        if [[ "$REPLY" == "q" || "$REPLY" == "Q" ]]; then
            echo "已退出。"
            exit 0
        fi

        if [[ -n "$choice" ]]; then
            # 数组索引从 0 开始，但 select 从 1 开始，所以要 -1
            local index=$((REPLY - 1))
            local selected_path="${theme_paths[$index]}"
            
            echo -e "\n您选择了: ${YELLOW}$choice${NC}"
            echo -e "物理路径: $selected_path"
            
            # 创建 /boot/grub/themes 目录（如果不存在）
            mkdir -p "$GRUB_THEMES_DIR"
            
            # 创建/更新软链接
            # -s: 软链接, -f: 强制(如果存在则删除), -n: 如果目标是目录，不将其视为目录处理
            ln -sfn "$selected_path" "$LINK_PATH"
            
            if [[ -L "$LINK_PATH" ]]; then
                echo -e "${GREEN}✔ 链接已创建: $LINK_PATH -> $selected_path${NC}"
            else
                echo -e "${RED}链接创建失败！${NC}"
                exit 1
            fi

            # 询问是否更新 GRUB
            read -p "是否立即更新 GRUB 配置生效? [y/N] " confirm
            if [[ "$confirm" =~ ^[yY]$ ]]; then
                update_grub_config
                echo -e "${GREEN}✔ 完成！重启后生效。${NC}"
            else
                echo -e "${YELLOW}已跳过 GRUB 更新。记得稍后手动更新。${NC}"
            fi
            
            break
        else
            echo -e "${RED}无效的选择，请重试。${NC}"
        fi
    done
}

main
