#!/bin/bash

# ===============================================================
#  Thunar Media Info v6.2 (Pixel Perfect Alignment)
# ===============================================================

# --- 1. 配置区域 ---
KITTY_CLASS="thunar_media_info_popup"

# --- 2. 帮助信息 ---
show_help() {
    echo "用法: $(basename "$0") [选项] <文件路径>"
    echo "  -f <文件>    指定输入文件"
    echo "  -h           显示帮助"
}

# --- 3. 语言检测 ---
DETECTED_LANG="${LC_ALL:-${LC_MESSAGES:-$LANG}}"
[[ "$DETECTED_LANG" == *"zh"* ]] && UI_LANG="zh" || UI_LANG="en"

# --- 4. 本地化字典 (核心修复：使用全角空格对齐) ---
# 注意：中文的"路　径"和"时　长"中间现在是一个全角空格
# 这样它们就被 printf 视为3个字符，与"文件名"完美对齐
LANG_TABLE='
STR_ERR_INPUT    | Error: No input file.                | 错误：未检测到输入文件。
STR_ERR_FFMPEG   | Error: ffmpeg not found.             | 错误：未找到 ffmpeg 命令。
STR_ERR_KITTY    | Error: Kitty not found.              | 错误：未找到 Kitty 终端。
STR_WIN_TITLE    | Media Info                           | 媒体信息
STR_LBL_NAME     |  File    |  文件名
STR_LBL_PATH     |  Path    |  路　径
STR_LBL_TIME     |  Time    |  时　长
STR_LBL_RATE     |  Rate    |  比特率
STR_LBL_VID      |  Video   |  视频流
STR_LBL_AUD      |  Audio   |  音频流
STR_Unknown      | Unknown                              | 未知
STR_Image        | (Image)                              | (图片)
STR_Stereo       | Stereo                               | 双声道
STR_Mono         | Mono                                 | 单声道
STR_Surround     | Surround                             | 环绕声
STR_PressKey     | Press any key to close...            | 按任意键关闭窗口...
'

# 解析字典
while IFS='|' read -r v e c; do
    v=$(echo "$v" | xargs); e=$(echo "$e" | xargs); c=$(echo "$c" | xargs)
    [ -z "$v" ] && continue
    case "$v" in \#*) continue ;; esac
    [ "$UI_LANG" = "zh" ] && eval "$v=\"$c\"" || eval "$v=\"$e\""
done <<EOF
$LANG_TABLE
EOF

# --- 5. 参数解析 ---
FILE=""
while getopts ":f:h" opt; do
  case $opt in
    f) FILE="$OPTARG" ;;
    h) show_help; exit 0 ;;
    *) ;;
  esac
done
[ -z "$FILE" ] && shift $((OPTIND-1)) && FILE="$1"
if [ -z "$FILE" ]; then echo "$STR_ERR_INPUT"; exit 1; fi

FILENAME=$(basename -- "$FILE")
DIRNAME=$(dirname -- "$FILE")

if ! command -v ffmpeg &> /dev/null; then echo "$STR_ERR_FFMPEG"; read -n 1; exit 1; fi

# --- 6. Kitty 启动逻辑 ---
if [ "$TERM" != "xterm-kitty" ] || [ "$KITTY_WINDOW_ID" == "" ]; then
    if command -v kitty &> /dev/null; then
        exec kitty --class "$KITTY_CLASS" --title "$STR_WIN_TITLE: $FILENAME" \
            -o initial_window_width=640 -o initial_window_height=420 -- "$0" "$FILE"
        exit
    else
        echo "$STR_ERR_KITTY"; read -n 1; exit 1
    fi
fi

# =========================================================
#                   数据渲染
# =========================================================

RAW_INFO=$(ffmpeg -i "$FILE" 2>&1)
BOLD='\033[1m'; GRAY='\033[90m'; CYAN='\033[36m'; GREEN='\033[32m'; YELLOW='\033[33m'; BLUE='\033[34m'; RESET='\033[0m'
clear

# --- 头部 ---
# 使用 %-9s，因为现在的中文标签全是统一的3字符长度（汉字或全角空格）
echo ""
printf " ${CYAN}%-9s${RESET}: ${BOLD}%s${RESET}\n" "$STR_LBL_NAME" "$FILENAME"
printf " ${CYAN}%-9s${RESET}: %s\n" "$STR_LBL_PATH" "$DIRNAME"

echo -e "${GRAY}----------------------------------------${RESET}"

# --- 时长与比特率 ---
DURATION_LINE=$(echo "$RAW_INFO" | grep "Duration")
if [ -n "$DURATION_LINE" ] && ! echo "$DURATION_LINE" | grep -q "N/A"; then
    DUR=$(echo "$DURATION_LINE" | awk -F', ' '{print $1}' | sed 's/.*Duration: //')
    BITRATE=$(echo "$DURATION_LINE" | awk -F', ' '{print $3}' | sed 's/bitrate: //')
    
    echo ""
    printf " ${YELLOW}%-9s${RESET}: ${BOLD}%s${RESET}\n" "$STR_LBL_TIME" "$DUR"
    printf " ${YELLOW}%-9s${RESET}: %s\n" "$STR_LBL_RATE" "$BITRATE"
    echo ""
fi

# --- 视频流 ---
VIDEO_STREAMS=$(echo "$RAW_INFO" | grep "Stream.*Video")
if [ -n "$VIDEO_STREAMS" ]; then
    echo "$VIDEO_STREAMS" | while read -r line; do
        CODEC=$(echo "$line" | grep -oE "Video: [a-zA-Z0-9]+" | cut -d' ' -f2)
        RES=$(echo "$line" | grep -oE "[0-9]{3,5}x[0-9]{3,5}" | head -1)
        FPS=$(echo "$line" | grep -oE "[0-9.]+\s+fps" | head -1)
        
        [ -n "$FPS" ] && INFO_STR="$CODEC | $RES | $FPS" || INFO_STR="$CODEC $STR_Image | $RES"
        printf " ${BLUE}%-9s${RESET}: %s\n" "$STR_LBL_VID" "$INFO_STR"
    done
fi

# --- 音频流 ---
AUDIO_STREAMS=$(echo "$RAW_INFO" | grep "Stream.*Audio")
if [ -n "$AUDIO_STREAMS" ]; then
    echo "$AUDIO_STREAMS" | while read -r line; do
        CODEC=$(echo "$line" | grep -oE "Audio: [a-zA-Z0-9]+" | cut -d' ' -f2)
        HZ=$(echo "$line" | grep -oE "[0-9]+\s+Hz")
        
        CHANNEL="$STR_Unknown"
        if echo "$line" | grep -q "stereo"; then CHANNEL="$STR_Stereo"; 
        elif echo "$line" | grep -q "mono"; then CHANNEL="$STR_Mono"; 
        else 
             CH_NUM=$(echo "$line" | grep -oE ", [0-9]+ channels" | tr -d ', a-z')
             [ -n "$CH_NUM" ] && CHANNEL="$CH_NUM $STR_Surround"
        fi

        INFO_STR="$CODEC | $HZ | $CHANNEL"
        printf " ${GREEN}%-9s${RESET}: %s\n" "$STR_LBL_AUD" "$INFO_STR"
    done
fi

# --- 底部 ---
echo ""
echo -e "${GRAY}----------------------------------------${RESET}"
echo -e "${BOLD}$STR_PressKey${RESET}"

tput civis 
read -n 1 -s -r
tput cnorm
