# --- [MODIFIED] Remote Dependency Manager (Strict Parsing) ---
check_dependencies() {
    log "$MSG_FETCH_LIST"
    
    mkdir -p "$STATE_DIR"

    local raw_temp="/tmp/shorin_niri_deps_raw.txt"
    local new_clean_list="/tmp/shorin_niri_deps_clean.txt"
    local old_sorted="/tmp/shorin_niri_deps_old_sorted.txt"
    local new_sorted="/tmp/shorin_niri_deps_new_sorted.txt"

    # 1. 下载清单
    if ! curl -sL "$APP_LIST_URL" -o "$raw_temp"; then
        warn "$MSG_FETCH_FAIL"
        return 0
    fi

    # 2. 强力清洗数据 (Strict Cleaning)
    rm -f "$new_clean_list"
    touch "$new_clean_list"
    
    # 逻辑说明：
    # sed 's/#.*//'  -> 删掉 # 和它后面所有内容
    # sed 's/AUR://' -> 删掉 AUR: 前缀
    # awk '{print $1}' -> 关键一步！只取第一列非空字符，自动丢弃前后所有空格/Tab
    # tr -cd '[:alnum:]@._+-\n' -> 防御性过滤，只保留合法的包名字符
    
    while read -r line; do
        # 跳过空行
        [ -z "$line" ] && continue
        
        local pkg_name=$(echo "$line" | sed 's/#.*//' | sed 's/AUR://' | awk '{print $1}' | tr -cd '[:alnum:]@._+-\n')
        
        [ -z "$pkg_name" ] && continue
        
        echo "$pkg_name" >> "$new_clean_list"
    done < "$raw_temp"
    rm -f "$raw_temp"

    # 3. 对比逻辑 (Diff Logic)
    if [ -f "$LAST_KNOWN_LIST" ]; then
        log "$MSG_CHECK_REMOVE"

        # [DEBUG]
        local count_old=$(wc -l < "$LAST_KNOWN_LIST")
        local count_new=$(wc -l < "$new_clean_list")
        # echo "Debug: Old DB has $count_old pkgs, New List has $count_new pkgs"

        sort "$LAST_KNOWN_LIST" > "$old_sorted"
        sort "$new_clean_list" > "$new_sorted"

        # 找出 Old 有但 New 没有的 (候选移除)
        local diff_pkgs=$(comm -23 "$old_sorted" "$new_sorted")
        
        rm -f "$old_sorted" "$new_sorted"

        local remove_candidates=()

        if [ -n "$diff_pkgs" ]; then
            while read -r pkg; do
                [ -z "$pkg" ] && continue
                
                # 再次确认系统里是否真的装了这个包
                # 这一次包名绝对是纯净的，pacman -Q 应该能准确识别
                if pacman -Q "$pkg" &> /dev/null; then
                    local msg_ask
                    msg_ask=$(printf "$MSG_ASK_REMOVE" "$pkg")
                    
                    echo -ne "${H_YELLOW}${msg_ask}${NC} "
                    read -r confirm_rm < /dev/tty
                    if [[ "$confirm_rm" =~ ^[yY] ]]; then
                        remove_candidates+=("$pkg")
                    fi
                fi
            done <<< "$diff_pkgs"
        fi

        # 执行移除
        if [ ${#remove_candidates[@]} -gt 0 ]; then
            log "$MSG_REMOVING"
            if ! sudo pacman -Rns "${remove_candidates[@]}"; then
                 warn "$MSG_REMOVE_FAIL"
            fi
        fi
    fi

    # 4. 安装新包逻辑
    local helper=""
    if command -v paru &> /dev/null; then helper="paru"
    elif command -v yay &> /dev/null; then helper="yay"
    else helper="sudo pacman"; fi

    local missing_pkgs=()
    if [ -f "$new_clean_list" ]; then
        while read -r pkg_name; do
            if ! pacman -Q "$pkg_name" &> /dev/null; then
                missing_pkgs+=("$pkg_name")
            fi
        done < "$new_clean_list"
    fi

    if [ ${#missing_pkgs[@]} -gt 0 ]; then
        warn "$MSG_INSTALL_DEPS ${missing_pkgs[*]}"
        if ! $helper -S --needed "${missing_pkgs[@]}"; then
            warn "$MSG_INSTALL_FAIL"
        fi
    else
        success "$MSG_DEPS_OK"
    fi

    # 5. 更新状态
    cp "$new_clean_list" "$LAST_KNOWN_LIST"
    rm -f "$new_clean_list"
}
